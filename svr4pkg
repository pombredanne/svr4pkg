#!/usr/bin/env perl
# svr4pkg - mimic solaris native svr4 package tools (pkgadd, pkgrm, pkginfo...)
# Copyright (C) 2013 Yann Rouillard <yann@pleides.fr.eu.org>

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
#

use strict;
use warnings;
use English qw( -no_match_vars );
use 5.010001;

#############################################################################
# Useful object classes
#############################################################################

{
    ########################################################################
    # Purpose:    The Package::Entry class is responsable for providing
    #             information to a file contained in a package and in the
    #             pkgmap file
    #             It also useful methods to audit and apply file fields.
    #
    ########################################################################
    package Package::Entry;

    use List::Util qw(first);
    use File::Spec::Functions qw(file_name_is_absolute catfile);
    use File::stat;
    use Fcntl ':mode';
    use POSIX qw(ceil);
    use English qw( -no_match_vars );
    use Carp qw(croak);

    use overload ( 'cmp' => \&compare, );

    # List of fields of the package entry object
    my @package_entry_fields = qw(
      part ftype class  pathname major minor mode owner group size cksum modtime
      filename targetname packages
    );

    # These value of fields are used we check that a local file is consistent
    # with a package entry
    my @compliance_fields = qw(
      ftype major minor mode owner group size cksum modtime
    );

    # Mapping between the file type and the format of the line for that file type,
    # both for a pkgmap file and the /var/sadm/install/contents file
    # Between the two, the only difference is that, in the latter
    # the pathname field is first and the part field is absent.
    my %line_format_for = (
        'pkgmap' => {
            'd' => [qw(part ftype class pathname mode owner group)],
            'x' => [qw(part ftype class pathname mode owner group)],
            's' => [qw(part ftype class pathname)],
            'l' => [qw(part ftype class pathname)],
            'f' => [qw(part ftype class pathname mode owner group size cksum modtime)],
            'v' => [qw(part ftype class pathname mode owner group size cksum modtime)],
            'e' => [qw(part ftype class pathname mode owner group size cksum modtime)],
            'p' => [qw(part ftype class pathname mode owner group size cksum modtime)],
            'b' => [qw(part ftype class pathname major minor owner group)],
            'c' => [qw(part ftype class pathname major minor owner group)],
            'i' => [qw(part ftype pathname size cksum modtime)],
        },
        'contents' => {
            'd' => [qw(pathname ftype class mode owner group packages)],
            'x' => [qw(pathname ftype class mode owner group packages)],
            's' => [qw(pathname ftype class packages)],
            'l' => [qw(pathname ftype class packages)],
            'f' => [qw(pathname ftype class mode owner group size cksum modtime packages)],
            'v' => [qw(pathname ftype class mode owner group size cksum modtime packages)],
            'e' => [qw(pathname ftype class mode owner group size cksum modtime packages)],
            'p' => [qw(pathname ftype class mode owner group size cksum modtime packages)],
            'b' => [qw(pathname ftype class major minor owner group packages)],
            'c' => [qw(pathname ftype class major minor owner group packages)],

            # No information files in the /var/sadm/install/contents file
        },
    );

    # The list of procedure scripts that can be present in packages
    my %allowed_scripts = map { $_ => 1 } qw(request checkinstall preinstall postinstall premove postremove);

    # Mapping between the system file type (as returned by stat)
    # and the pkgmap file type
    my %pkgmap_ftype_for = (
        Fcntl::S_IFREG => 'f',
        Fcntl::S_IFBLK => 'b',
        Fcntl::S_IFCHR => 'c',
        Fcntl::S_IFDIR => 'd',
        Fcntl::S_IFLNK => 's',
        Fcntl::S_IFIFO => 'p',
    );

    use constant BLOCK_SIZE             => 512;
    use constant EXECUTABLE_PERMISSIONS => oct('111');

    ## Public methods

    #
    # Purpose:    Creates and returns a package entry object of the
    #             given type and whose attributes are initialized
    #             with the given values
    #
    # Parameters:
    #   $entry_type - either:
    #                  pkgmap:   for a package entry in a pkgmap file
    #                  contents: for a package entry in the contents file
    #   $file_type  - the file type of the pkgmap entry
    #   $values     - a hash containing the values of the attributes
    #   @pkginst    - an optional list of package that owns this entry
    #
    sub new {
        my ( $class, $entry_type, $file_type, $values, @pkginsts ) = @_;
        my $self = {};

        @{$self}{@package_entry_fields} = undef;

        $self->{packages} = [];

        my $allowed_fields = $line_format_for{$entry_type}{$file_type};
        foreach my $field ( @{$allowed_fields} ) {
            if ( exists( $values->{$field} ) ) {
                $self->{$field} = $values->{$field};
            }
        }
        bless( $self, $class );

        $self->add_owners(@pkginsts);

        if ( $self->is_symlink() or $self->is_hardlink() ) {
            ( $self->{filename}, $self->{targetname} ) = split( /=/, $self->{pathname}, 2 );
        } else {
            $self->{filename} = $self->{pathname};
        }

        return ($self);
    }

    #
    # Purpose:    Creates and returns a pkgmap_entry object from a valid
    #             line in a pkgmap file
    # Parameters:
    #   $line     - a string containing a line describing the file and its properties
    #   $format   - the format of the line which can be either:
    #                pkgmap: for a line in a pkgmap file
    #                contents: for a line in the /var/sadm/install/contents file
    #   @pkginsts - an optional list of package names that owns this entry
    #
    sub new_from_line {
        my ( $class, $line, $format, @pkginsts ) = @_;
        my $values = {};

        my @items = split( /\s+/, $line );
        my $ftype = $items[1];

        # the list of attributes presents in a line differ depending
        # on the file type, so we get the associated line template and
        # initialize the attributes accordingly
        my $field_name_at = $line_format_for{$format}{$ftype};
        foreach my $index ( 0 .. $#{$field_name_at} ) {
            $values->{ $field_name_at->[$index] } = shift(@items);
        }

        # The package attribute is different, it's a list and not a scalar
        if ( $format eq 'contents' ) {
            $values->{packages} = [ $values->{packages}, @items ];
        }

        return ( new( $class, $format, $ftype, $values, @pkginsts ) );
    }

    #
    # Purpose:    Creates and returns a pkgmap_entry object whose attributes
    #             values are based on the attributes of an existing file
    #
    # Parameters:
    #   $filename          - path of the filename
    #   $additional_values - additional attributes values
    #   @pkginsts          - an optional list of package names that owns this entry
    #
    sub new_from_file {
        my ( $class, $filename, $additional_values, @pkginst ) = @_;
        my $values = {};

        # We remove the target part for hard and symlink
        my ($realname) = ( $filename =~ m/^([^=]+)/ );

        my $stats = lstat($realname) or croak("ERROR: Can't get the status info of file $realname !");
        $values->{part}     = 1;
        $values->{ftype}    = $pkgmap_ftype_for{ S_IFMT( $stats->mode() ) };
        $values->{pathname} = $filename;
        $values->{class}    = 'none';
        $values->{size}     = $stats->size();
        $values->{owner}    = getpwuid( $stats->uid() );
        $values->{group}    = getgrgid( $stats->gid() );
        $values->{modtime}  = $stats->mtime();
        $values->{mode}     = sprintf( '%.4o', S_IMODE( $stats->mode() ) );
        $values->{minor}    = $stats->rdev() % 256;
        $values->{major}    = int( $stats->rdev() / 256 );

        if ( $values->{ftype} =~ /[fev]/ ) {
            $values->{cksum} = ( split( /\s+/, `/usr/bin/sum $filename`, 2 ) )[0];
            if ( $CHILD_ERROR >> 8 ) {
                croak('ERROR: couldn\'t run the binary /usr/bin/sum !');
            }
        }

        $values->{ keys( %{$additional_values} ) } = values( %{$additional_values} );
        return ( new( $class, 'pkgmap', $values->{ftype}, $values, @pkginst ) );
    }

    #
    # A set of useful methods to test some properties of the file referenced
    # by the pkgmap entry
    #
    sub is_directory        { my $self = shift; return ( $self->{ftype} eq 'd' ); }
    sub is_information_file { my $self = shift; return ( $self->{ftype} eq 'i' ); }
    sub is_symlink          { my $self = shift; return ( $self->{ftype} eq 's' ); }
    sub is_hardlink         { my $self = shift; return ( $self->{ftype} eq 'l' ); }
    sub is_pipe             { my $self = shift; return ( $self->{ftype} eq 'p' ); }
    sub is_block_device     { my $self = shift; return ( $self->{ftype} eq 'b' ); }
    sub is_character_device { my $self = shift; return ( $self->{ftype} eq 'c' ); }
    sub is_regular_file { my $self = shift; return ( $self->{ftype} =~ /[fve]/ ); }
    sub is_relative { my $self = shift; return ( not file_name_is_absolute( $self->{pathname} ) ); }

    sub is_executable {
        my $self = shift;
        return ( $self->{ftype} eq 'f' and oct( $self->{mode} ) & EXECUTABLE_PERMISSIONS );
    }

    sub is_installation_script {
        my $self = shift;
        return (
            $self->{ftype} eq 'i' and ( $allowed_scripts{ $self->{pathname} }
                or $self->{pathname} =~ m/[ir][.].*/ )
        );
    }

    #
    # Purpose:    Overloads the cmp algorithm
    #
    sub compare {
        my ( $pkgmap_entry1, $pkgmap_entry2 ) = @_;
        return ( $pkgmap_entry1->{filename} cmp $pkgmap_entry2->{filename} );

    }

    #
    # Purpose:    Returns the number of blocks that would be occupied by the
    #             file on the disk
    #
    sub get_block_size {
        my $self = shift;

        # although information files do have a size information, they
        # are not accounted for in the original pkginfo tool
        if ( not defined( $self->{size} ) or $self->is_information_file() ) {
            return (0);
        }
        return ceil( $self->{size} / BLOCK_SIZE );
    }

    #
    # Purpose:    Returns the corresponding line to be added in the
    #             /var/sadm/install/contents file for this entry
    # Parameters:
    #   $basedir - BASEDIR value for the corresponding package if it exists
    #
    sub as_contents_line {
        my ( $self, $basedir ) = @_;

        # information files are not stored in the contents file
        return if ( $self->is_information_file() );

        my @contents_line_fields = @{ $line_format_for{'contents'}{ $self->{ftype} } };

        # We remove the last one, 'packages', because it's a list that we must handle differently
        pop(@contents_line_fields);

        my @values = map ( { $self->{$_} } @contents_line_fields );
        push( @values, @{ $self->{packages} } );

        # If we were given a basedir, we will use to transform relative path into absolutes ones
        # The first value is always the pathname so we directly change it
        if ( defined($basedir) and $self->is_relative() ) {
            $values[0] = catfile( $basedir, $values[0] );
        }

        my $line = join( ' ', @values );
        return ($line);
    }

    #
    # Purpose:    Add one or more packages to the list of packages
    #             that own this entry
    # Parameters:
    #   @pkginsts - the list of SVR4 package names that own this entry
    #
    sub add_owners {
        my ( $self, @pkginsts ) = @_;

        foreach my $pkginst (@pkginsts) {
            next if ( first { $_ eq $pkginst } @{ $self->{packages} } );
            push( @{ $self->{packages} }, $pkginst );
        }
    }

    #
    # Purpose:    Remove one or more packages from the list of packages
    #             that own this entry
    # Parameters:
    #   @pkginsts - the list of SVR4 package names that don't own this
    #               entry anymore
    #
    sub remove_owners {
        my ( $self, @pkginsts ) = @_;

        my @packages;
        foreach my $pkginst ( @{ $self->{packages} } ) {
            next if ( first { $_ eq $pkginst } @pkginsts );
            push( @packages, $pkginst );
        }
        $self->{packages} = \@packages;
    }

    #
    # Purpose:    Modify the permissions, owner and group of the file,
    #             directory, pipe... at the given path so it matches
    #             the values defined in the current pkgmap entry
    # Parameters:
    #   $path - the path of the file, directory, pipe... whose
    #           permissions and ownership will be changed.
    #
    sub apply_pkgmap_properties {
        my ( $self, $path ) = @_;

        if ( defined( $self->{owner} ) and defined( $self->{group} ) ) {
            my $uid = $self->{owner} ne '?' ? getpwnam( $self->{owner} ) : -1;
            my $gid = $self->{group} ne '?' ? getgrnam( $self->{group} ) : -1;
            chown( $uid, $gid, $path ) or croak("ERROR: can't set owner/group of file $path !");
        }

        if ( defined( $self->{mode} ) and $self->{mode} ne '?' ) {
            chmod( oct( $self->{mode} ), $path ) or croak("ERROR: can't set permissions of file $path !");
        }

        if ( defined( $self->{modtime} ) ) {
            my $modtime = $self->{modtime};
            utime( $modtime, $modtime, $path ) or croak("ERROR: can't set modification time of file $path !");
        }
    }

    #
    # Purpose:    Checks that the properties of the file at the given
    #             path match the informations stored in the pkgmap
    #             entry line. That includes size, cksum, owner, group,
    #             permissions.
    #             It returns a list of non compliant fields or undef
    #             if the file doesn't exist or can't be read.
    #
    # Parameters:
    #   $path - the path of the file whose fields will be checked
    #
    sub check_file_properties {
        my ( $self, $path ) = @_;
        my @non_compliant_fields;

        return if ( !-r $path );

        my $pkgmap_entry = Package::Entry->new_from_file($path);

        foreach my $field (@compliance_fields) {
            next if ( not defined( $self->{$field} ) );

            if ( ( $self->is_regular_file() or $self->is_hardlink() )
                and $pkgmap_entry->is_regular_file() )
            {

                # A pkgmap entry of file type e, f, v or l just look like
                # a regular file on the filesystem so we must consider that it's ok
                next;
            }

            # A 'question mark' in owner, group or mode means we don't care about
            # the actual value so we skip the comparison
            if ( first { $_ eq $field } qw(owner group mode) ) {
                next if ( $self->{$field} eq '?' or $pkgmap_entry->{$field} eq '?' );
            }

            if ( $self->{$field} ne $pkgmap_entry->{$field} ) {
                push(
                    @non_compliant_fields,
                    {
                        field    => $field,
                        expected => $self->{$field},
                        actual   => $pkgmap_entry->{$field}
                    }
                );

                # if the file don't have the same type, there is
                # no need to compare the other fields
                last if ( $field eq 'ftype' );
            }
        }

        return ( \@non_compliant_fields );
    }

    ########################################################################
    # Purpose:    The Package::Entry::Database class is responsable for
    #             accessing and updating the database containing the list
    #             of files installed by package on the current system.
    #             The database is in fact a simple plain file containing
    #             a line for each file installed.
    #             It is usually the /var/sadm/install/contents file
    #
    ########################################################################
    package Package::Entry::Database;

    use File::Basename qw(dirname);
    use File::Path qw(make_path);
    use List::Util qw(first);
    use File::Spec::Functions qw(catfile);
    use Carp qw(croak);

    #
    # Purpose:    Creates and returns a package database object
    #             whose content is initialized from the given
    #             filename.
    #
    # Parameters:
    #   $filename - path of the file containing the list of files
    #               installed by packages on the system.
    #               The file should have the same format as the
    #               /var/sadm/install/contents file
    #
    sub new {
        my ( $class, $filename ) = @_;
        my $self = {
            filename    => $filename,
            raw_entries => undef,
            index       => undef,
        };

        bless( $self, $class );
        return ($self);
    }

    #
    # Purpose:    Add an entry in the package entry database
    #
    # Parameters:
    #   $pkgmap_entry - a valid package entry object
    #
    sub register_entry {
        my ( $self, $pkgmap_entry, $basedir ) = @_;
        my $raw_entries = $self->_get_raw_entries();
        my $index       = $self->_get_index();
        my $filename    = $pkgmap_entry->{filename};
        my $packages    = $pkgmap_entry->{packages};

        if ( defined($basedir) and $pkgmap_entry->is_relative() ) {
            $filename = catfile( $basedir, $filename );
        }

        if ( exists( $index->{by_filename}{$filename} ) ) {

            # Directories are a special case, they are allowed
            # to be owned by more than one package
            if ( $pkgmap_entry->is_directory() and defined( ${ $index->{by_filename}{$filename} } ) ) {
                my $old_pkgmap_entry =
                  Package::Entry->new_from_line( ${ $index->{by_filename}{$filename} }, 'contents' );
                if ( $old_pkgmap_entry->is_directory() ) {
                    $pkgmap_entry->add_owners( @{ $old_pkgmap_entry->{packages} } );
                }
            }
            ${ $index->{by_filename}{$filename} } = $pkgmap_entry->as_contents_line($basedir);

        } else {
            push( @{ $self->{raw_entries} }, $pkgmap_entry->as_contents_line($basedir) );
            $index->{by_filename}{$filename} = \$self->{raw_entries}[ $#{ $self->{raw_entries} } ];
        }

        foreach my $pkginst ( @{$packages} ) {
            push( @{ $index->{by_package}{$pkginst} }, $index->{by_filename}{$filename} );
        }
    }

    #
    # Purpose:    Remove an entry from the package entry database
    #
    # Parameters:
    #   $pkgmap_entry - a valid package entry object
    #
    sub unregister_entry {
        my ( $self, $pkgmap_entry, $basedir ) = @_;

        my $raw_entries = $self->_get_raw_entries();
        my $index       = $self->_get_index();
        my $filename    = $pkgmap_entry->{filename};

        if ( defined($basedir) and $pkgmap_entry->is_relative() ) {
            $filename = catfile( $basedir, $filename );
        }

        if ( exists( $index->{by_filename}{$filename} ) and defined( ${ $index->{by_filename}{$filename} } ) ) {

            # Directories are a special case, they are allowed
            # to be owned by more than one package
            my $old_pkgmap_entry = Package::Entry->new_from_line( ${ $index->{by_filename}{$filename} }, 'contents' );
            if ( $old_pkgmap_entry->is_directory() ) {
                $pkgmap_entry->remove_owners( @{ $old_pkgmap_entry->{packages} } );
                if ( @{ $pkgmap_entry->{packages} } ) {

                    # There are still some remaining packages that own the directory
                    # so we update it and don't delete it
                    ${ $index->{by_filename}{$filename} } = $pkgmap_entry->as_contents_line($basedir);
                    return;
                }
            }
            ${ $index->{by_filename}{$filename} } = undef;
        }
    }

    #
    # Purpose:    Check if the given package entry already
    #             exists in the package database.
    #
    # Parameters:
    #   $pkgmap_entry - a valid package entry object
    #   $same_owner   - if true, has_entry will return true
    #                    only if an entry with the same owner is found
    #                   if false, has_entry will return true
    #                    if an entry exists but without the same owners
    #                    as the given pkgmap_entry
    #
    sub has_entry {
        my ( $self, $pkgmap_entry, $same_owner ) = @_;

        my $raw_entries = $self->_get_raw_entries();
        my $index       = $self->_get_index();
        my $filename    = $pkgmap_entry->{filename};

        # we check if the given path is already registered in the database,
        if ( exists( $index->{by_filename}{$filename} ) and defined( ${ $index->{by_filename}{$filename} } ) ) {
            my $candidate_entry = Package::Entry->new_from_line( ${ $index->{by_filename}{$filename} }, 'contents' );
            foreach my $pkginst ( @{ $pkgmap_entry->{packages} } ) {
                if ( not( first { $_ eq $pkginst } @{ $candidate_entry->{packages} } ) ) {
                    return ( not $same_owner );
                }
            }
            return ($same_owner);
        }

        return;
    }

    #
    # Purpose:    Return the list of package entries installed
    #             on the system and owned by the given pkginst
    #
    # Parameters:
    #   $pkginst - the SVR4 package name
    #
    sub get_package_entries {
        my ( $self, $pkginst ) = @_;
        my @entries;

        my $index = $self->_get_index();

        if ( exists( $index->{by_package}{$pkginst} ) ) {
            foreach my $line_ref ( @{ $index->{by_package}{$pkginst} } ) {
                next if not defined( ${$line_ref} );
                push( @entries, Package::Entry->new_from_line( ${$line_ref}, 'contents' ) );
            }
        }

        return ( \@entries );
    }

    #
    # Purpose:    Save the package database on the file system
    #             This method is automatically called when the
    #             object is destroyed.
    #
    sub commit {
        my ($self) = @_;

        return if ( not defined( $self->{raw_entries} ) );

        make_path( dirname( $self->{filename} ) );

        my $index = $self->_get_index();
        my $temp_file = File::Temp->new( TEMPLATE => $self->{filename} . '_XXXX' );

        open( my $fh, '>', $temp_file ) or croak("ERROR: can't open $temp_file");
        foreach my $filename ( sort ( keys( %{ $index->{by_filename} } ) ) ) {
            next if ( not defined( ${ $index->{by_filename}{$filename} } ) );
            print $fh ${ $index->{by_filename}{$filename} } . "\n";
        }
        close($fh) or croak("ERROR: an error occured while closing file $temp_file !");

        rename( $temp_file, $self->{filename} ) or croak("ERROR: can't rename $temp_file to $self->{filename} !");

        $self->{raw_entries} = undef;
        $self->{index}       = undef;
    }

    #
    # Purpose:    Destructor
    #
    sub DESTROY {
        my ($self) = @_;
        $self->commit();
    }

    ## Private methods

    #
    # Purpose:    Return the entries stored in the database file
    #
    sub _get_raw_entries {
        my ($self) = @_;

        # We lazily load the database file it if has not yet been opened
        if ( not defined( $self->{raw_entries} ) ) {
            $self->{raw_entries} = [];

            if ( -r $self->{filename} ) {
                open( my $fh, '<', $self->{filename} ) or croak( 'ERROR: can\'t open ' . $self->{filename} );
                @{ $self->{raw_entries} } = <$fh>;
                chomp( @{ $self->{raw_entries} } );
                close($fh) or croak("ERROR: an error occured while closing file $self->{filename}");
            }
        }

        return ( $self->{raw_entries} );
    }

    #
    # Purpose:    Return the index by package and filename
    #
    sub _get_index {
        my ($self) = @_;

        if ( not defined( $self->{index} ) ) {
            $self->{index} = {
                by_package  => {},
                by_filename => {},
            };

            my $filename_re  = qr{[^=\s]+};    # the filename part (not including the target)
            my $target_re    = qr{=\S+};       # the target of symbolic|hard link
            my $any_field_re = qr{\s+\S+};     # any field
            my $package_re   = qr{\S+\s*};

            foreach my $line ( @{ $self->_get_raw_entries() } ) {
                my ( $filename, $packages ) = (
                    $line =~ qr{
                                    ^($filename_re)(?:$target_re)?
                                    (?:\sd(?:$any_field_re){4}     # The directory type has only four info fields but it 
                                                                   #  can have several packages as owners
                                     |(?:$any_field_re)+)          # For the other type, only the last field is the package
                                                                   #  so we consume pretty much all the fselds except the last
                                    \s+((?:$package_re)+)$         # The last field(s) are the packages owning the file
                                }x
                );

                # We ignore invalid lines and also comment lines that begin with '#'
                next if ( not $filename or not $packages );
                $self->{index}{by_filename}{$filename} = \$line;
                foreach my $pkginst ( split( /\s+/, $packages ) ) {
                    push( @{ $self->{index}{by_package}{$pkginst} }, \$line );
                }
            }
        }

        return ( $self->{index} );
    }

    ########################################################################
    # Purpose:   The Package class is responsable for providing information
    #            about a package and methods to run basic package procedures
    #            (file installation, script execution...)
    #
    ########################################################################
    package Package;
    use File::Copy;
    use File::Temp;
    use File::Basename qw(dirname basename);
    use File::Path qw(make_path);
    use File::Spec::Functions qw(catfile rel2abs);
    use List::Util qw(first);
    use POSIX qw(strftime);
    use Carp qw(croak);

    use Fatal qw( close copy );

    my @short_format_fields = qw(CATEGORY PKGINST NAME);
    my @long_format_fields  = qw(
      PKGINST NAME   CATEGORY ARCH  VERSION
      VENDOR  PSTAMP HOTLINE  EMAIL STATUS  FILES
    );

    # Those fields are not saved after package installation
    my @unexported_fields = qw(INST_DATADIR PKG_CLIENT_OS);

    my @package_statistics = (
        { 'name' => 'pathnames',         'display' => 'spooled pathnames' },
        { 'name' => 'directories',       'display' => 'directories' },
        { 'name' => 'executables',       'display' => 'executables' },
        { 'name' => 'information_files', 'display' => 'package information files' },
        { 'name' => 'blocks',            'display' => 'blocks used (approx)' },
    );

    use constant RESTRICTED_MASK        => oct('077');
    use constant SANE_MASK              => oct('022');
    use constant EXECUTABLE_PERMISSIONS => oct('755');

    ## Public methods

    #
    # Purpose:    Create a new instance of a Package object
    #             given a svr4 package in the file system format
    # Parameters:
    #   $path    - the path where the package is located
    #   $pkginst - the svr4 name of the package
    #   $options - a hash contains optional arguments:
    #
    #       package_entries - the list of pkgmap entries belonging
    #                         to the package. It's useful when
    #                         the package doesn't have a pkgmap file.
    #
    #       path_mappings   - a set of path transformations to apply
    #                         on the destination paths of file and in
    #                         the contents of the shell scripts.
    #                         It's a hash where keys and values are
    #                         paths, each path key must be mapped
    #                         to the path value.
    #
    sub new {
        my ( $class, $path, $pkginst, $options ) = @_;
        my $self = {
            path            => rel2abs($path),
            pkginst         => $pkginst,
            pkgmap_file     => catfile( $path, $pkginst, 'pkgmap' ),
            package_entries => [],
            dependencies    => {},
            path_mappings   => {},
            statistics      => undef,
            trace           => 0,
        };

        # Handling optional arguments
        foreach my $option_name (qw(path_mappings package_entries_callback trace)) {
            if ( exists( $options->{$option_name} ) ) {
                $self->{$option_name} = $options->{$option_name};
            }
        }
        bless( $self, $class );

        $self->_load_pkginfo();
        $self->_load_depend();
        $self->_setup_base_environnement();

        return ($self);
    }

    #
    # Purpose:    Returns informations and statistics about the current
    #             package in a human readable format
    # Parameters:
    #   $display_mode - 'short' => a one-line of information
    #                   'long' => a complete dump of the informations and
    #                             statistics available on the package
    #
    sub get_info {
        my ( $self, $display_mode ) = @_;

        if ( $display_mode eq 'short' ) {
            return ( join( ' ', @{ $self->{pkginfo} }{@short_format_fields} ) );
        }

        if ( not defined( $self->{statistics} ) ) {
            $self->_update_statistics();
        }

        my $info = '';
        foreach my $key ( grep { exists( $self->{pkginfo}{$_} ) } @long_format_fields ) {
            $info .= sprintf( "%10s:  %s\n", ( $key, $self->{pkginfo}{$key} ) );
        }
        $info .= sprintf( "%10s:  %s\n", qw(STATUS spooled) );

        my $header = 'FILES:';
        foreach my $statistic (@package_statistics) {
            $info .=
              sprintf( "%11s  %7i %s\n",
                ( $header, $self->{statistics}{ $statistic->{name} }, $statistic->{display} ) );

            # The "FILES:" header is just on the first line, so we set if
            # as an empty string just after the first line
            if ($header) {
                $header = ' ';
            }
        }

        return ($info);
    }

    #
    # Purpose:     Get the value of a given parameter
    #
    # Parameters:
    #   $parameter - the name of the parameter
    #
    sub get_parameter {
        my ( $self, $parameter ) = @_;
        return if not( exists( $self->{pkginfo}{$parameter} ) );

        return ( $self->{pkginfo}{$parameter} );
    }

    #
    # Purpose:     Set the value of a given parameter
    #
    # Parameters:
    #   $parameter - the name of the parameter
    #   $value     - the value to set
    #
    sub put_parameter {
        my ( $self, $parameter, $value ) = @_;
        $self->{pkginfo}{$parameter} = $value;
    }

    #
    # Purpose:     Check of the given script is available whereas
    #              in the package itself or on the system (for class
    #              action scripts).
    #              It returns the full path to the scripts or undef
    #              if not script is found.
    #
    # Parameters:
    #   $script             - the name of the script to check for
    #   $alternate_location - an alternate list of paths where scripts must be
    #                         searched if they are not provided in the package
    #
    sub check_installation_script {
        my ( $self, $script, $alternate_locations ) = @_;

        if ( exists( $self->{installation_scripts}{$script} ) ) {
            my $pkgmap_entry = $self->{installation_scripts}{$script};
            return ( $self->_build_path($pkgmap_entry) );
        }

        if ( defined($alternate_locations) ) {
            foreach my $location ( @{$alternate_locations} ) {
                my $filename = "$location/$script";
                return ($filename) if ( -f $filename );
            }
        }

        return;
    }

    #
    # Purpose:     Install the package information files (pkginfo, pkgmap
    #              installation scripts...) at the given location.
    #
    # Parameters:
    #   $dest         - the root directory where files must be installed
    #
    sub install_information_files {
        my ( $self, $dest ) = @_;

        my @pkgmap_entries =
          grep { $_->is_information_file() and $_->{pathname} ne 'pkginfo' } @{ $self->get_entries() };
        $self->_install_files_by_copy( \@pkgmap_entries, catfile( $dest, 'install' ) );
        $self->put_parameter( 'INSTDATE', strftime( '%b %d %Y %H:%M', localtime() ) );
        $self->_dump_pkginfo( catfile( $dest, 'pkginfo' ) );
    }

    #
    # Purpose:    Create or install the package files of the given type
    #             on the server at the given location, running the corresponding
    #             class action scripts if required.
    # Parameters:
    #   $dest                    - the root directory where files must be installed
    #   $action_scripts_location - an optional directory list where class action scripts
    #                              must be looked for.
    #
    sub install_files {
        my ( $self, $dest, $action_scripts_locations ) = @_;

        my @classes = split( /\s+/, $self->get_parameter('CLASSES') );

        # The none class is always processed first
        @classes = ( 'none', grep { $_ ne 'none' } @classes );

        foreach my $class (@classes) {

            # We install the files following the procedure described in "Script Processing
            # During Package Installation" in the # "Application Packaging Developer's Guide"

            my ( $special_entries, $regular_entries, $hardlink_entries ) = $self->_get_class_entries($class);

            my $action_script = $self->check_installation_script( "i.$class", $action_scripts_locations );

            # We first create symbolic links, devices, named pipes, and directories.
            my $failed_entries = $self->_install_files_by_copy( $special_entries, $dest );

            # Then we install the regular files using the class action script if it exists
            if ( defined($action_script) ) {

                # If any of the special entries could not be created, they will be feed to the class
                # action scripts as explained in "How Classes Are Processed During Package Installation"
                push( @{$regular_entries}, @{$failed_entries} );

                $self->_install_files_by_action_script( $class, $regular_entries, $dest, $action_script );
            } else {
                $self->_install_files_by_copy( $regular_entries, $dest );
            }

            # Then we create the hardlinks
            $self->_install_files_by_copy( $hardlink_entries, $dest );

            foreach my $pkgmap_entry ( @{$special_entries}, @{$regular_entries}, @{$hardlink_entries} ) {
                $pkgmap_entry->apply_pkgmap_properties( $self->_build_path( $pkgmap_entry, $dest ) );
            }
        }
    }

    #
    # Purpose:    Remove the package files on the server at the given location,
    #             running the corresponding class action scripts if required.
    # Parameters:
    #   $dest                    - the root directory where files have been installed
    #   $action_scripts_location - an optional directory where class action scripts
    #                              must be looked for.
    #
    sub remove_files {
        my ( $self, $dest, $action_scripts_locations ) = @_;

        my @classes = split( /\s+/, $self->get_parameter('CLASSES') );

        # The classes are processed in reversed order at removal time
        # and the none class is always processed last
        @classes = reverse( 'none', grep { $_ ne 'none' } @classes );

        foreach my $class (@classes) {

            # We remove the files following the procedure described in "Script Processing
            # During Package removal in the "Application Packaging Developer's Guide"

            my ( $special_entries, $regular_entries, $hardlink_entries ) = $self->_get_class_entries($class);

            my $action_script = $self->check_installation_script( "r.$class", $action_scripts_locations );

            # We first remove the hardlinks
            $self->_remove_files_by_unlink( $hardlink_entries, $dest );

            # Then we remove the regular files using the class action script if it exists
            if ( defined($action_script) ) {
                $self->_remove_files_by_action_script( $class, $regular_entries, $dest, $action_script );
            } else {
                $self->_remove_files_by_unlink( $regular_entries, $dest );
            }

            # Last, we remove symbolic links, devices, named pipes, and directories.
            $self->_remove_files_by_unlink( $special_entries, $dest );
        }
    }

    #
    # Purpose:    Check that the property of the files currently installed
    #             match the ones specified in the package.
    #             Returns the list of non compliant files and associated
    #             errors.
    #
    # Parameters:
    #   $dest - the root directory where files have been installed
    #
    sub check_installed_files {
        my ( $self, $dest ) = @_;
        my @inconsistent_files;

        foreach my $pkgmap_entry ( @{ $self->get_entries() } ) {
            my $filename = $self->_build_path( $pkgmap_entry, $dest );
            my $non_compliant_fields = $pkgmap_entry->check_file_properties($filename);

            if ( not defined($non_compliant_fields) or @{$non_compliant_fields} ) {
                push(
                    @inconsistent_files,
                    {
                        package_entry => $pkgmap_entry,
                        errors        => $non_compliant_fields
                    }
                );
            }
        }

        return ( \@inconsistent_files );
    }

    #
    # Purpose:    Executes the given scripts in the package and returns
    #             the exit code of the script.
    #             If a script is not present in the package, nothing is
    #             done and a success code is returned.
    #
    # Parameters:
    #   $script - the name of the script that must be launched, it must
    #             be one of the standard package scripts.
    #
    # Note:       Class action scripts are not run using this subroutine,
    #             they are automatically launched by the install_files
    #             subroutine;
    #
    sub execute_procedure_script {
        my ( $self, $script ) = @_;

        return if not exists( $self->{installation_scripts}{$script} );

        my $pkgmap_entry = $self->{installation_scripts}{$script};
        my $script_path  = $self->_build_path($pkgmap_entry);

        $script_path = $self->_relocate_path_in_script($script_path);

        my $response_file;
        my @command = ( '/usr/bin/sh', $script_path );

        if ( $script =~ /checkinstall|request/ ) {

            # These two scripts can write in the new parameters that must be
            # taken into account
            $response_file = File::Temp->new();

            # They also need to be run under a non-privileged user so we must
            # use the su binary to launch the real command
            my $fallback_user = $script eq 'checkinstall' ? 'nobody' : 'root';
            my $runas_user = getpwnam('install') ? 'install' : $fallback_user;
            chown( $runas_user, $response_file );
            my $real_command = join( ' ', ( @command, $response_file ) );
            @command = ( '/usr/bin/su', $runas_user, '-c', $real_command );
        }

        local @ENV{ keys( %{ $self->{pkginfo} } ) } = values( %{ $self->{pkginfo} } );
        my $ret = system(@command);
        if ($response_file) {
            $self->_load_pkginfo( { append => 1, filename => $response_file } );
        }
        return ($ret);
    }

    #
    # Purpose:    Returns the list of files owned by a package
    #             as a list of package::entry objects.
    #
    sub get_entries {
        my ($self) = @_;

        if ( not( @{ $self->{package_entries} } ) ) {

            # If we were given a callback to find the package entries at
            # creation time, it takes precedence over pkgmap
            if ( $self->{package_entries_callback} ) {
                $self->{package_entries} = &{ $self->{package_entries_callback} }();
            } else {
                $self->_load_pkgmap();
            }
        }

        return ( $self->{package_entries} );
    }

    ## Private methods

    #
    # Purpose:    Setup some basic informations that will be passed in
    #             the environment of each installation script
    #
    # Parameters:
    #   $file       - the path of the parameters file to load
    #
    sub _setup_base_environnement {
        my ($self) = @_;

        $self->put_parameter( 'PKGINST',       $self->{pkginst} );
        $self->put_parameter( 'INST_DATADIR',  $self->{path} );
        $self->put_parameter( 'PKG_CLIENT_OS', 'Solaris' );
        $self->put_parameter( 'TZ',            $ENV{TZ} );
        if ( not $self->get_parameter('BASEDIR') ) {
            $self->put_parameter( 'BASEDIR', '/' );
        }
    }

    #
    # Purpose:    Parse the pkginfo file
    #
    sub _load_pkginfo {
        my ( $self, $options ) = @_;
        my $pkginfo_file;

        if ( exists( $options->{append} ) and not $options->{append} ) {
            $self->{pkginfo} = {};
        }

        if ( exists( $options->{filename} ) and $options->{filename} ) {
            $pkginfo_file = $options->{filename};
        } else {
            $pkginfo_file = catfile( $self->{path}, $self->{pkginst}, 'pkginfo' );
        }

        open( my $fh, '<', $pkginfo_file ) or croak("ERROR: can't open pkginfo file at $pkginfo_file !");
        while ( my $line = <$fh> ) {
            chomp($line);
            my ( $key, $value ) = split( /=/, $line, 2 );
            $self->{pkginfo}{$key} = $value;
        }
        close($fh) or croak("ERROR: an error occured while closing file $pkginfo_file !");
    }

    #
    # Purpose:    Load a parameters file which has the following form
    #              PARAMETER=VALUE
    #
    # Parameters:
    #   $file       - the path of the parameters file to load
    #
    sub _dump_pkginfo {
        my ( $self, $file ) = @_;

        open( my $fh, '>', $file ) or return;
        foreach my $key ( keys( %{ $self->{pkginfo} } ) ) {
            next if first { $_ eq $key } @unexported_fields;
            printf $fh ( "%s=%s\n", ( $key, $self->{pkginfo}{$key} ) );
        }
        close($fh);
    }

    #
    # Purpose:    Parse the pkgmap file located in the package and
    #             initialize the list of package entries.
    #             This function can also parse the /var/sadm/install/contents
    #             file for a locally installed package and it will only
    #             pick the entry relevant to this package.
    #
    sub _load_pkgmap {
        my ($self) = @_;
        my $pkgmap_file = $self->{pkgmap_file};
        return if not( -r $pkgmap_file );

        my $pkginst = $self->{pkginst};

        open( my $fh, '<', $pkgmap_file ) or croak("ERROR: can't open $pkgmap_file");
        while ( my $line = <$fh> ) {
            next if ( $line =~ /^[:#]/ );
            chomp($line);

            my $pkgmap_entry = Package::Entry->new_from_line( $line, 'pkgmap', $self->{pkginst} );
            push( @{ $self->{package_entries} }, $pkgmap_entry );

            # We note what installation scripts are provided in the package
            if ( $pkgmap_entry->is_installation_script() ) {
                $self->{installation_scripts}{ $pkgmap_entry->{pathname} } = $pkgmap_entry;
            }
        }
        close($fh) or croak("ERROR: an error occured while closing file $pkgmap_file !");
    }

    #
    # Purpose:    Parse the depend file located in the package and
    #             initialize the list of package entries.
    #             At the end of this method, the 'pkgmap' internal
    #             attr is properly initialized as a list of
    #             Package::Entry objects.
    #
    # Parameters:
    #   $pkgmap_file - the path of the pkgmap file
    #
    sub _load_depend {
        my $self = shift;
        my $depend_file = catfile( $self->{path}, $self->{pkginst}, 'install/depend' );

        if ( -r $depend_file ) {
            open( my $fh, '<', $depend_file ) or croak("ERROR: can't open $depend_file !");
            while ( my $line = <$fh> ) {
                my ( $type, $pkginst, $name ) = ( $line =~ /^\s*([PIR])\s+(\S+)\s+(.*)/ );
                next if not( defined($type) );
                push( @{ $self->{dependencies}{$type} }, $pkginst );
            }
            close($fh) or croak("ERROR: an error occured while closing file $depend_file !");
        }
    }

    #
    # Purpose:    Update various information about the current
    #             package according to the list of files owned
    #             by the package.
    #             This includes the list of installation scripts
    #             and the statistics about the files types and size.
    #
    sub _update_statistics {
        my ($self) = @_;

        $self->{statistics} = {
            directories       => 0,
            executables       => 0,
            pathnames         => 1,
            information_files => 1,
            blocks            => 0,
        };

        foreach my $pkgmap_entry ( @{ $self->get_entries() } ) {

            # We update some statistics about the package contents while
            # parsing the pkgmap file
            for ($pkgmap_entry) {
                if ( $_->is_directory() )        { $self->{statistics}{directories}       += 1 }
                if ( $_->is_executable() )       { $self->{statistics}{executables}       += 1 }
                if ( $_->is_information_file() ) { $self->{statistics}{information_files} += 1 }
            }
            $self->{statistics}{pathnames} += 1;
            $self->{statistics}{blocks} += $pkgmap_entry->get_block_size();

        }
    }

    #
    # Purpose:    Given a Package::Entry objet, this method returns
    #             the source path where the corresponding file is located
    #             or the destination path where the corresponding file
    #             must be installed depending on the argument.
    #
    # Parameters:
    #   $pkgmap_entry - a Package::Entry object
    #
    sub _build_path {
        my ( $self, $pkgmap_entry, $dest ) = @_;
        my @path_components;

        my $filename = $pkgmap_entry->{filename};

        if ( defined($dest) ) {
            push( @path_components, $dest );
            if ( $pkgmap_entry->is_relative() ) {
                push( @path_components, $self->get_parameter('BASEDIR') );
            }

            foreach my $path ( keys( %{ $self->{path_mappings} } ) ) {
                my $new_path = $self->{path_mappings}{$path};
                $filename =~ s/^$path/$new_path/;
            }

        } else {
            push( @path_components, $self->{path}, $self->{pkginst} );
            if ( $pkgmap_entry->is_information_file() ) {
                push( @path_components, 'install' );
            } else {
                push( @path_components, $pkgmap_entry->is_relative() ? 'reloc' : 'root' );
            }
        }
        push( @path_components, $filename );

        return ( catfile(@path_components) );
    }

    #
    # Purpose:    Given a class, this methods returns the list of
    #             package entries belonging to this class, separated
    #             in special entries, regular entries and hardlink entries
    #
    # Parameters:
    #   $class - name of the class
    #
    sub _get_class_entries {
        my ( $self, $class ) = @_;

        my @special_entries;    # name pipe, symlink, block and character devices, directory
        my @regular_entries;    # entries of type f, v or e
        my @hardlink_entries;

        foreach my $pkgmap_entry ( sort( @{ $self->get_entries() } ) ) {
            next if ( not defined( $pkgmap_entry->{class} ) or $pkgmap_entry->{class} ne $class );

            for ($pkgmap_entry) {
                if ( $_->is_hardlink() ) {
                    push( @hardlink_entries, $pkgmap_entry );

                } elsif ( $_->is_regular_file() ) {
                    push( @regular_entries, $pkgmap_entry );

                } else {
                    push( @special_entries, $pkgmap_entry );
                }
            }
        }

        return ( \@special_entries, \@regular_entries, \@hardlink_entries );
    }

    #
    # Purpose:       Install the files of the package on the target location
    #                using a standard copy/link/symlink operation, depending
    #                on the file type.
    # Parameters:
    #   $pkgmap_entry - the list of pkgmap entries whose corresponding files
    #                   must be installed on the target file system.
    #   $dest         - the root directory where files must be installed
    #
    sub _install_files_by_copy {

        my ( $self, $pkgmap_entries, $dest ) = @_;
        my @failed_entries;

        # we make sure the files are first created with restrictive access
        my $original_umask = umask(RESTRICTED_MASK);

        foreach my $pkgmap_entry ( @{$pkgmap_entries} ) {
            my $dest_path = $self->_build_path( $pkgmap_entry, $dest );
            make_path( dirname($dest_path) );

            my $success = 1;

            for ($pkgmap_entry) {
                if ( $_->is_symlink() ) { $success = symlink( $pkgmap_entry->{targetname}, $dest_path ); }
                if ( $_->is_hardlink() ) { $success = link( $pkgmap_entry->{targetname}, $dest_path ); }
                if ( $_->is_directory() and ( !-d $dest_path ) ) { $success = mkdir($dest_path); }

                if ( $_->is_regular_file() or $_->is_information_file() ) {
                    my $src_path = $self->_build_path($pkgmap_entry);
                    $success = copy( $src_path, $dest_path );
                }
            }

            if ( not $success ) {
                push( @failed_entries, $pkgmap_entry );
            }
        }

        # we restore the previous umask;
        umask($original_umask);

        return ( \@failed_entries );
    }

    #
    # Purpose:       Remove the files of the package on the target location
    #                using a standard deletion operation.
    #
    # Parameters:
    #   $pkgmap_entry - the list of pkgmap entries whose corresponding files
    #                   must be installed on the target file system.
    #   $dest         - the root directory where files must be installed
    #
    sub _remove_files_by_unlink {
        my ( $self, $pkgmap_entries, $dest ) = @_;

        foreach my $pkgmap_entry ( reverse( @{$pkgmap_entries} ) ) {
            my $dest_path = $self->_build_path( $pkgmap_entry, $dest );

            if ( $pkgmap_entry->is_directory() ) {
                rmdir($dest_path);
            } else {
                unlink($dest_path);
            }
        }
    }

    #
    # Purpose:       Install the files of the package on the target location
    #                using a standard copy/link/symlink operation, depending
    #                on the file type.
    # Parameters:
    #   $pkgmap_entry  - the list of pkgmap entries whose corresponding files
    #                    must be installed on the target file system.
    #   $dest          - the root directory where files must be installed
    #   $action_script - path of the action script that will take care of
    #                    installating the pkgmap entries
    #
    sub _install_files_by_action_script {
        my ( $self, $class, $pkgmap_entries, $dest, $action_script ) = @_;

        # The script has to make sure the file are created with the appropriate
        # permissions depending on the security requirements but we make sure
        # a sane default mask is used at least in the worst case
        my $original_umask = umask(SANE_MASK);

        $action_script = $self->_relocate_path_in_script($action_script);
        my $command = $self->{trace} ? "sh -x $action_script" : $action_script;
        $command .= ' ENDOFCLASS';

        local @ENV{ keys( %{ $self->{pkginfo} } ) } = values( %{ $self->{pkginfo} } );
        open( my $fh, '|-', $command ) or croak("ERROR: can't run $action_script !");

        # if the current class is stored in the PKG_CAS_PASSRELATIVE package variable
        # it means we will pass the src path as a relative path from the
        my $pass_relative;
        my $pass_relative_classes = $self->get_parameter('PKG_CAS_PASSRELATIVE');

        if ($pass_relative_classes) {
            if ( first { $_ eq $class } split( /\s+/, $pass_relative_classes ) ) {
                $pass_relative = 1;

                # In passrelative mode, the first entry is the path to the directory
                # where the package content has been extracted
                print $fh catfile( $self->{path}, $self->{pkginst} ) . "\n";
            }
        }

        foreach my $pkgmap_entry ( @{$pkgmap_entries} ) {

            if ($pass_relative) {
                my $src_path = $pkgmap_entry->{filename};
                print $fh "$src_path\n";
            } else {

                # An action class script takes as input of list of files to install
                my $src_path = $pkgmap_entry->is_regular_file() ? $self->_build_path($pkgmap_entry) : '/dev/null';
                my $dest_path = $self->_build_path( $pkgmap_entry, $dest );
                print $fh "$src_path $dest_path\n";
            }
        }

        # we restore the previous umask;
        umask($original_umask);

        my $result = eval { close($fh); };
    }

    #
    # Purpose:       Remove the files of the package on the target location
    #                using a class action script.
    #
    # Parameters:
    #   $pkgmap_entry  - the list of pkgmap entries whose corresponding files
    #                    must be installed on the target file system.
    #   $dest          - the root directory where files must be installed
    #   $action_script - path of the action script that will take care of
    #                    installating the pkgmap entries
    #
    sub _remove_files_by_action_script {
        my ( $self, $class, $pkgmap_entries, $dest, $action_script ) = @_;

        $action_script = $self->_relocate_path_in_script($action_script);
        my $command = $self->{trace} ? "sh -x $action_script" : $action_script;
        $command .= ' ENDOFCLASS';

        local @ENV{ keys( %{ $self->{pkginfo} } ) } = values( %{ $self->{pkginfo} } );
        open( my $fh, '|-', $command ) or croak("ERROR: can't run script $action_script !");

        foreach my $pkgmap_entry ( reverse( @{$pkgmap_entries} ) ) {

            # An action class script takes as input of list of files to remove
            my $dest_path = $self->_build_path( $pkgmap_entry, $dest );
            print $fh "$dest_path\n";
        }
        my $result = eval { close($fh); };
    }

    #
    # Purpose:       Parses the content of the given scripts
    #                and replaces any path found
    #                It returns a path to a script which don't
    #                contains any unmapped path.
    #                It can be a temporary new script if modifications
    #                were applied.
    #
    # Parameters:
    #   $script - the name of the script
    #
    sub _relocate_path_in_script {
        my ( $self, $script ) = @_;

        my @mapped_paths = keys( %{ $self->{path_mappings} } );
        return ($script) if ( not @mapped_paths );

        # Our temporary patched script will automatically
        # be deleted when it is no longer referenced
        my $patched_script = File::Temp->new( UNLINK => 1 );
        chmod( EXECUTABLE_PERMISSIONS, $patched_script );

        open( my $fh, '<', $script ) or croak("ERROR: can't open file $script !");
        while ( my $line = <$fh> ) {
            foreach my $path ( keys( %{ $self->{path_mappings} } ) ) {
                my $new_path = $self->{path_mappings}{$path};
                $line =~ s{$path}{$new_path}x;
            }
            print $patched_script $line;
        }
        close($fh);
        close($patched_script);

        return ($patched_script);
    }

    ########################################################################
    # Purpose:   The Package::Manager class is responsable for providing
    #            access to package database and high-level method to install
    #            or remove package.
    #            It also takes charge of user interactions during package
    #            operations.
    #
    ########################################################################
    package Package::Manager;

    use List::Util qw(first);
    use File::Spec::Functions qw(catfile);
    use File::Basename qw(dirname);
    use File::Path qw(make_path remove_tree);
    use IPC::Cmd qw(can_run);
    use Carp qw(croak);

    use constant NATIVE_ACTION_SCRIPTS_LOCATION => '/usr/sadm/install/scripts/';

    # Packager::Manager error codes
    use constant SUCCESS          => 0;
    use constant CONFLICT_ERROR   => 1;
    use constant DEPENDENCY_ERROR => 2;
    use constant EXTRACT_ERROR    => 3;

    my @relocatable_binaries = qw(pkgparam pkginfo installf removef);

    ## Public methods

    #
    # Purpose:    Create an instance of package manager using the
    #             given configuration
    #
    # Parameters:
    #   $package_manager_config - a hash reference containing the
    #                             configuration parameters
    #
    sub new {
        my ( $class, $package_manager_config ) = @_;
        my $self = {};

        %{$self} = %{$package_manager_config};
        $self->{pkg_directory} = catfile( $self->{root_path}, $self->{admin_directory}, 'pkg' );
        $self->{content_file}  = catfile( $self->{root_path}, $self->{admin_directory}, 'install/contents' );
        $self->{path_mappings} = {};
        $self->{package_entry_database} = Package::Entry::Database->new( $self->{content_file} );

        # We will make sure any class actions scripts installed by a package
        # is relocated to a different location. This is required to install
        # shared installation scripts on systems where /usr is readonly
        if ( $self->{relocate_class_script} ) {
            my $path = NATIVE_ACTION_SCRIPTS_LOCATION;
            $self->{path_mappings}{$path} = $self->{action_scripts_location};
        }

        # We will make sure that scripts will not contains any aboluste reference
        # to the original location of native standard svr4 tools.
        # This is required on systems where /usr is readonly to ensure that
        # alternate tools provided by svr4pkg are used instead.
        # All scripts will be modified before being executed.
        if ( $self->{patch_pkg_location} ) {
            my $path = '/usr/s?bin/(?=' . join( '|', @relocatable_binaries ) . ')';
            $self->{path_mappings}{$path} = '';
        }

        return ( bless( $self, $class ) );
    }

    #
    # Purpose:    Create an instance of package manager using the
    #             given configuration
    #
    # Parameters:
    #   $pkginst - SVR4 package name of the package to return
    #   $device  - optional path to the device where the package
    #              is present
    #
    sub get_package {
        my ( $self, $pkginst, $options ) = @_;
        my $package_entries;
        my $package_options = { path_mappings => $self->{path_mappings} };

        my $device = exists( $options->{device} ) ? $options->{device} : $self->{pkg_directory};

        if ( exists( $options->{trace} ) ) {
            $package_options->{trace} = $options->{trace};
        }

        if ( -f $device or $device =~ m{^https?://} ) {

            # The package is in the datastream format
            # we must first convert it to filesystem format
            my ( $ret, $info ) = $self->extract_package("$device");
            return if ( $ret != SUCCESS );

            $pkginst = $info;
            $device  = $self->{spool_directory};
        }

        if ( $device eq $self->{pkg_directory} ) {

            return if ( not $self->is_package_installed($pkginst) );

            # The package is a local one, so it doesn't have a
            # pkgmap file and the file information are stored in
            # the /var/sadm/install/contents file, we just set the
            # entries_callback
            $package_options->{package_entries_callback} =
              sub { return ( $self->{package_entry_database}->get_package_entries($pkginst) ); };
        }

        return if ( not defined($pkginst) );

        my $package = Package->new( $device, $pkginst, $package_options );

        if ( defined( $self->{binaries_location} ) ) {

            # We make sure the location of the svr4pkg tools are
            # in the paths so they will found by installation scripts
            $package->put_parameter( 'PATH', $self->{binaries_location} . ':/usr/sbin:/usr/bin:' . $ENV{PATH} );
        }

        return ($package);
    }

    #
    # Purpose:    Extract a svr4 package in the datastream format
    #             into a svr4 package in the file system format
    #             (.e.g. a directory containg all the files)
    #             and returns the path to the extracted
    #
    # Parameters:
    #   $package_file - the path of the svr4 package in datastream format
    #
    sub extract_package {
        my ( $self, $package_file ) = @_;

        if ( $package_file =~ m{^https?://} ) {

            my $binary =
                can_run('curl') ? 'curl --silent --location --output'
              : can_run('wget') ? 'wget --quiet --output-document'
              : undef
              or croak('ERROR: can\'t locate curl or wget binary !');

            my $url = $package_file;
            $package_file = File::Temp->new( UNLINK => 1 );
            system("$binary '$package_file' '$url'");
        }

        make_path( $self->{spool_directory} );
        my $command = "pkgtrans -o $package_file " . $self->{spool_directory} . ' all';
        my $result  = `$command 2>&1`;

        my ($pkg_name) = ( $result =~ /Transferring <([^>]+)> package instance/ );

        if ( defined($pkg_name) and $result =~ /no permission to overwrite existing path/ ) {
            remove_tree( catfile( $self->{spool_directory}, $pkg_name ) );
            `$command 2>&1`;
        }

        return ( EXTRACT_ERROR, undef ) if ( not defined($pkg_name) );
        return ( SUCCESS, $pkg_name );
    }

    #
    # Purpose:    Check if the given package is installed
    #
    sub is_package_installed {
        my ( $self, $pkginst ) = @_;
        return ( -e catfile( $self->{pkg_directory}, $pkginst, 'pkginfo' ) );
    }

    #
    # Purpose:    Returns the list of svr4 package names that
    #             are installed on the system
    #
    sub list_installed_packages {
        my $self = shift;

        opendir( my $pkgdir, $self->{pkg_directory} );
        my @installed_pkgs = grep { $_ !~ /^[.]{1,2}$/ } readdir($pkgdir);
        closedir($pkgdir);

        return ( SUCCESS, \@installed_pkgs );
    }

    #
    # Purpose:    Register the given file in the package entry
    #             database (usually the /var/sadm/install/contents file)
    #
    # Parameters:
    #   $pkgmap_entry - the pkgmap entry that must be registered
    #
    sub register_entry {
        my ( $self, $pkgmap_entry, $basedir ) = @_;
        $self->{package_entry_database}->register_entry( $pkgmap_entry, $basedir );
        return ( SUCCESS, undef );

    }

    #
    # Purpose:    Unregisters the given file from the package entry
    #             database (usually the /var/sadm/install/contents file)
    #
    # Parameters:
    #   $pkgmap_entry - the pkgmap entry that must be registered
    #
    sub unregister_entry {
        my ( $self, $pkgmap_entry, $basedir ) = @_;
        $self->{package_entry_database}->unregister_entry( $pkgmap_entry, $basedir );
        return ( SUCCESS, undef );
    }

    #
    # Purpose:    Install the given package on the system
    #
    # Parameters:
    #   $package - a Package object whose content must be
    #              installed on the server.
    #   $options - a hash of various options:
    #               - force => if 1, force the package installation
    #                          even if there are some file conflict
    #
    sub install_package {
        my ( $self, $package, $options ) = @_;
        my $dest = $self->{root_path};

        my @missing_dependencies;
        foreach my $dependency ( @{ $package->{dependencies}{'P'} } ) {
            if ( not $self->is_package_installed($dependency) ) {
                push( @missing_dependencies, $dependency );
            }
        }
        if (@missing_dependencies) {
            return ( DEPENDENCY_ERROR, \@missing_dependencies );
        }

        if ( not( $options->{force} ) ) {
            my $conflicts = $self->_check_file_conflict( $package, $dest );
            if ( @{$conflicts} ) {
                return ( CONFLICT_ERROR, $conflicts );
            }
        }

        if ( $self->is_package_installed( $package->{pkginst} ) ) {
            $package->put_parameter( 'UPDATE', 'yes' );
        }

        $self->_verbose( '## Installing package ' . $package->{pkginst} );

        $self->_verbose('## Registering the package');
        $self->_register_package($package);

        $self->_verbose('## Executing checkinstall script');
        $package->execute_procedure_script('checkinstall');

        $self->_verbose('## Executing preinstall script');
        $package->execute_procedure_script('preinstall');

        $self->_verbose('## Installing package files');
        my $action_scripts_locations =
          [ catfile( $self->{root_path}, $self->{action_scripts_location} ), NATIVE_ACTION_SCRIPTS_LOCATION ];
        $package->install_files( $dest, $action_scripts_locations );

        $self->_verbose('## Executing postinstall script');
        $package->execute_procedure_script('postinstall');

        return ( SUCCESS, undef );
    }

    #
    # Purpose:    Removes the given package from the system
    #
    # Parameters:
    #   $package - a Package object whose content must be
    #              installed on the server.
    #   $dest    - the root location where the package files
    #              must be installed.
    #
    sub remove_package {
        my ( $self, $package, $options ) = @_;
        my $dest = $self->{root_path};

        # We first check if there is some installed packages that depend
        # on this one
        if ( not( $options->{force} ) ) {
            my @dependent_packages;
            foreach my $pkginst ( @{ $self->list_installed_packages() } ) {
                next if ( $pkginst eq $package->{pkginst} );
                my $installed_package = $self->get_package($pkginst);
                if ( first { $_ eq $package->{pkginst} } @{ $installed_package->{dependencies}{P} } ) {
                    push( @dependent_packages, $pkginst );
                }
            }
            if (@dependent_packages) {
                return ( DEPENDENCY_ERROR, \@dependent_packages );
            }
        }

        $self->_verbose( '## Removing package ' . $package->{pkginst} . "\n" );

        $self->_verbose('## Executing preremove script');
        $package->execute_procedure_script('preremove');

        $self->_verbose('## Removing package files');
        my $action_scripts_locations =
          [ catfile( $self->{root_path}, $self->{action_scripts_location} ), NATIVE_ACTION_SCRIPTS_LOCATION ];
        $package->remove_files( $dest, $action_scripts_locations );

        $self->_verbose('## Executing postremove script');
        $package->execute_procedure_script('postremove');

        $self->_verbose('## Unregistering the package');
        $self->_unregister_package($package);

        return ( SUCCESS, undef );
    }

    ## Private methods

    #
    # Purpose:    Print a verbose message about what's going on !
    #
    # Parameters:
    #   $message - the message to display
    #
    sub _verbose {
        my ( $self, $message ) = @_;
        print "$message\n";
    }

    #
    # Purpose:    Register the package in the package database and
    #             package content database.
    #
    # Parameters:
    #   $package - the package that must be registered
    #
    sub _register_package {
        my ( $self, $package ) = @_;

        # update /var/sadm/pkg
        # we just copy the information files of the package
        # in the installed packages directory
        my $package_directory = catfile( $self->{pkg_directory}, $package->{pkginst} );
        $package->install_information_files($package_directory);

        my $pkgmap  = $package->get_entries();
        my $basedir = $package->get_parameter('BASEDIR');
        foreach my $pkgmap_entry ( @{$pkgmap} ) {
            next if ( $pkgmap_entry->is_information_file() );
            $self->register_entry( $pkgmap_entry, $basedir );
        }
    }

    #
    # Purpose:    Register the package in the package database and
    #             package content database.
    #
    # Parameters:
    #   $package - the package that must be registered
    #
    sub _unregister_package {
        my ( $self, $package ) = @_;

        my $pkgmap  = $package->get_entries();
        my $basedir = $package->get_parameter('BASEDIR');
        foreach my $pkgmap_entry ( @{$pkgmap} ) {
            next if ( $pkgmap_entry->is_information_file() );
            $self->unregister_entry( $pkgmap_entry, $basedir );
        }

        # update /var/sadm/pkg
        # we just delete the package directory in /var/sadm/pkg
        my $package_directory = catfile( $self->{pkg_directory}, $package->{pkginst} );
        remove_tree($package_directory);

    }

    #
    # Purpose:    Check if there are existing files that conflicts
    #             with the files of the given package
    #             Returns the list of conflicting files.
    #
    # Parameters:
    #   $package - the package that must be registered
    #   $dest    - the root location where files are installed
    #
    sub _check_file_conflict {
        my ( $self, $package, $dest ) = @_;
        my @conflicts;

        foreach my $pkgmap_entry ( @{ $package->get_entries() } ) {

            # Directories can be shared between several packages so we don't care
            next if ( $pkgmap_entry->is_directory() );

            next if ( $self->{package_entry_database}->has_entry( $pkgmap_entry, 1 ) );

            if ( $self->{package_entry_database}->has_entry( $pkgmap_entry, 0 )
                or -e $package->_build_path( $pkgmap_entry, $dest ) )
            {
                push( @conflicts, $pkgmap_entry->{filename} );
            }
        }

        return ( \@conflicts );
    }

}

#############################################################################
# Useful functions
#############################################################################

#
# Purpose:    Determine if we are running in a interactive session
#             Note: we should use IO::Interactive but we don't want
#             to depend on any module
#             Beside, we are sure that we will not use *ARGV here.
#
sub is_interactive {
    return -t *STDIN && -t *STDOUT;
}

#############################################################################
# Main program
#############################################################################

use Getopt::Long;
use POSIX qw(strftime);
use File::Basename qw(basename dirname);

# Default configuration for the package manager
my %package_manager_config = (
    'root_path'               => '/',
    'admin_directory'         => '/var/sadm',
    'spool_directory'         => '/var/spool/pkg',
    'action_scripts_location' => '/var/sadm/install/scripts/',
    'relocate_class_script'   => 1,
    'patch_pkg_location'      => 1,
    'binaries_location'       => dirname($PROGRAM_NAME),
);

## Commands subroutines

# The options common to all svr4pkg commands
my %common_options_specs = ( 'root_path' => { 'spec' => 'R=s', 'default' => '/' }, );

# This hash will be filled with the
my %commands_options_specs;

# This hash will be filled with name of each command
my %available_commands;

## pkginfo command ######################################################

$available_commands{'pkginfo'}     = \&info_cmd;
$commands_options_specs{'pkginfo'} = {
    'device'      => { 'spec' => 'd=s', 'default' => '/var/sadm/pkg' },
    'long_format' => { 'spec' => 'l',   'default' => 0 },
};

sub info_cmd {

    my ( $package_manager, $options, @arguments ) = @_;
    my $package_names;

    if (@arguments) {
        $package_names = \@arguments;
    } else {
        my ( $ret, $info ) = $package_manager->list_installed_packages();
        $package_names = $info;
    }

    my $package_options = { 'device' => $options->{device} };

    foreach my $package_name ( @{$package_names} ) {
        my $package = $package_manager->get_package( $package_name, $package_options );
        if ( not defined($package) ) {
            print STDERR "ERROR: information for \"$package_name\" was not found\n";
        } else {
            print( $package->get_info( $options->{long_format} ? 'long' : 'short' ) . "\n" );
        }
    }

    return (1);
}

## pkgadd command ######################################################

$available_commands{'pkgadd'}     = \&add_cmd;
$commands_options_specs{'pkgadd'} = {
    'adminfile'      => { 'spec' => 'a=s', 'default' => undef },
    'device'         => { 'spec' => 'd=s', 'default' => '/var/spool/pkg' },
    'trace'          => { 'spec' => 'v',   'default' => 0 },
    'noninteractive' => { 'spec' => 'n',   'default' => 0 },
};

sub add_cmd {

    my ( $package_manager, $options, @arguments ) = @_;

    my $pkginst = @arguments ? shift(@arguments) : undef;

    my $package_options = { 'device' => $options->{device}, trace => $options->{trace} };
    my $package = $package_manager->get_package( $pkginst, $package_options );

    if ( not defined $package ) {
        print STDERR ("ERROR: no package name given or no package found in $options->{device}\n");
        return;
    }

    my ( $ret, $info ) = $package_manager->install_package($package);

    if ( $ret == Package::Manager::DEPENDENCY_ERROR ) {
        print("The following packages are not installed and are required to install $pkginst:\n");

        # In that case, $info is a reference to a list of missing required packages
        print( join( "\n", map { "\t$_" } @{$info} ) . "\n\n" );
        return;
    }

    if ( $ret == Package::Manager::CONFLICT_ERROR ) {

        my $force;

        if ( not $options->{noninteractive} ) {
            print("The following files are already installed on the system:\n");

            # In that case, $info is a reference to a list of conflicting files
            print( join( "\n", map { "\t$_" } @{$info} ) . "\n\n" );

            if ( is_interactive() ) {
                print 'Would you like to install the package anyway (y/n) ? ';
                my $answer = <STDIN>;
                $force = ( $answer =~ /^[Yy]$/ );
            }
        }

        # We assume yes in non interactive mode to be usable by pkgutil
        # until we add real support the admin file through the "-a admin"
        if ( $force or $options->{noninteractive} ) {
            ( $ret, $info ) = $package_manager->install_package( $package, { force => 1 } );
        }
    }

    return ( $ret == Package::Manager::SUCCESS );
}

## pkgrm command ######################################################

$available_commands{'pkgrm'}     = \&rm_cmd;
$commands_options_specs{'pkgrm'} = {
    'adminfile'      => { 'spec' => 'a=s', 'default' => undef },
    'trace'          => { 'spec' => 'v',   'default' => 0 },
    'noninteractive' => { 'spec' => 'n',   'default' => 0 },
};

sub rm_cmd {

    my ( $package_manager, $options, @arguments ) = @_;

    return if ( not @arguments );

    my $package_options = { trace => $options->{trace} };

    my @packages_list;
    foreach my $pkginst (@arguments) {
        my $package = $package_manager->get_package( $pkginst, $package_options );
        if ( not defined($package) ) {
            print STDERR "ERROR: no package associated with <$pkginst>\n";
            exit(1);
        }
        push( @packages_list, $package );
    }

    foreach my $package (@packages_list) {
        my ( $ret, $info ) = $package_manager->remove_package($package);

        if ( $ret == Package::Manager::DEPENDENCY_ERROR ) {

            my $force;

            if ( not $options->{noninteractive} ) {
                print( 'The following packages depend on ' . $package->{pkginst} . ":\n" );

                # In that case, $info is a reference to a list of dependent packages
                print( join( "\n", map { "\t$_" } @{$info} ) . "\n\n" );

                if ( is_interactive() ) {
                    print 'Would you like to remove the package anyway (y/n) ? ';
                    my $answer = <STDIN>;
                    $force = ( $answer =~ /^[Yy]$/ );
                }
            }

            # We assume yes in non interactive mode to be usable by pkgutil,
            # until we add real support the admin file through the "-a admin"
            if ( $force or $options->{noninteractive} ) {
                ( $ret, $info ) = $package_manager->remove_package( $package, { force => 1 } );
            }
        }
        if ( $ret != Package::Manager::SUCCESS ) {
            return;
        }
    }

    return (1);
}

## pkgparam command ######################################################

$available_commands{pkgparam} = \&param_cmd;
$commands_options_specs{pkgparam} = { 'device' => { 'spec' => 'd=s', 'default' => '/var/sadm/pkg' }, };

sub param_cmd {

    my ( $package_manager, $options, @arguments ) = @_;

    return if ( not @arguments );

    my $pkginst         = shift(@arguments);
    my $package_options = { device => $options->{device} };
    my $package         = $package_manager->get_package( $pkginst, $package_options );
    print join( "\n", map { $package->{pkginfo}->{$_} } @arguments ) . "\n";

    return (1);
}

## pkgchk command ######################################################

$available_commands{pkgchk} = \&chk_cmd;
$commands_options_specs{pkgchk} = { 'device' => { 'spec' => 'd=s', 'default' => '/var/sadm/pkg' }, };

my %field_display_name = (
    'ftype'   => 'file type',
    'size'    => 'file size',
    'modtime' => 'modtime',
    'cksum'   => 'file cksum',
    'group'   => 'group name',
    'owner'   => 'owner name',
    'mode'    => 'permissions',
    'major'   => 'device major',
    'minor'   => 'device minor',
);

sub chk_cmd {
    my ( $package_manager, $options, @arguments ) = @_;
    my $package_names;

    if (@arguments) {
        $package_names = \@arguments;
    } else {
        my ( $ret, $info ) = $package_manager->list_installed_packages();
        $package_names = $info;
    }

    my $package_options = { device => $options->{device} };

    foreach my $pkginst ( @{$package_names} ) {
        my $package = $package_manager->get_package( $pkginst, $package_options );

        foreach my $entry_error ( @{ $package->check_installed_files( $options->{root_path} ) } ) {
            my $package_entry = $entry_error->{package_entry};
            printf STDERR ( "ERROR: %s\n", ( $package_entry->{filename} ) );

            if ( not defined( $entry_error->{errors} ) ) {
                print STDERR "    pathname does not exist\n";
                next;
            }

            foreach my $error ( @{ $entry_error->{errors} } ) {
                my ( $field, $expected, $actual ) = @{$error}{ 'field', 'expected', 'actual' };
                if ( $field eq 'modtime' ) {
                    $expected = strftime( '%D %r', localtime($expected) );
                    $actual   = strftime( '%D %r', localtime($actual) );
                }
                printf STDERR ( "\t%s <%s> expected <%s> actual\n",
                    ( $field_display_name{$field}, $expected, $actual ) );
            }
        }
    }

    return (1);
}

## installf command ######################################################

$available_commands{installf}     = \&installf_cmd;
$commands_options_specs{installf} = {
    'class' => { 'spec' => 'c=s', 'default' => 'none' },
    'final' => { 'spec' => 'f',   'default' => 0 },
};

use constant MIN_FIELDS_COUNT => 3;
use constant MAX_FIELDS_COUNT => 8;

sub installf_cmd {

    my ( $package_manager, $options, @arguments ) = @_;

    return if ( @arguments < MIN_FIELDS_COUNT );

    # We're supposed to make the modifications when installf is last called
    # with the -f option, but in fact, we make them immediately so we can
    # ignore this option.
    return (1) if ( $options->{'final'} );

    my ( $pkginst, $pathname, $ftype ) = @arguments[ 0 .. MIN_FIELDS_COUNT - 1 ];
    my %fields = ( 'class' => $options->{class} );

    if ( @arguments >= MAX_FIELDS_COUNT ) {
        $fields{ 'major', 'minor', 'mode', 'owner', 'group' } = @arguments[ MIN_FIELDS_COUNT .. MAX_FIELDS_COUNT - 1 ];
    } elsif ( @arguments > MIN_FIELDS_COUNT ) {
        $fields{ 'mode', 'owner', 'group' } = @arguments[ MIN_FIELDS_COUNT .. $#arguments ];
    }

    return if ( !-r $pathname );

    my $pkgmap_entry = Package::Entry->new_from_file( $pathname, \%fields, $pkginst );
    my ( $ret, $info ) = $package_manager->register_entry($pkgmap_entry);

    return ( $ret == Package::Manager::SUCCESS );
}

## removef_cmd command ######################################################

$available_commands{removef} = \&removef_cmd;
$commands_options_specs{removef} = { 'final' => { 'spec' => 'f', 'default' => 0 }, };

sub removef_cmd {

    my ( $package_manager, $options, @arguments ) = @_;

    return if ( @arguments <= 1 );

    # We're supposed to make the modifications when removef is last called
    # with the -f option, but in fact, we make them immediately so we can
    # ignore this option.
    return (1) if ( $options->{'final'} );

    my $pkginst         = shift(@arguments);
    my @pathnames       = sort(@arguments);
    my $package         = $package_manager->get_package($pkginst);
    my $package_entries = $package->get_entries();

    foreach my $pathname (@pathnames) {

        return if ( !-r $pathname );

        my $pkgmap_entry = first { $_->{filename} eq $pathname } @{$package_entries};
        next if ( not defined($pkgmap_entry) );
        my ( $ret, $info ) = $package_manager->unregister_entry( $pkgmap_entry, $pkginst );

        if ( $ret != Package::Manager::SUCCESS ) {
            return;
        }
    }

    return (1);
}

## usage command ######################################################

sub usage {
    my $ret = shift;
    print <<'EOF';
svr4pkg, mimic solaris native svr4 package tools (pkgadd, pkgrm, pkginfo...)

Usage: svr4pkg [command] [options] [package...]
EOF
    exit($ret);
}

## Command line parsing and execution

# One can create symlinks to svr4pkg using original solaris svr4 package tools
# as names. In that case, the symlink name is used to know the command to be run.
my $command = basename($PROGRAM_NAME);
if ( not exists( $available_commands{$command} ) and @ARGV ) {

    # otherwise the first argument is used to know which command must be used
    $command = 'pkg' . shift(@ARGV);
}

if ( not exists( $available_commands{$command} ) ) {
    usage(1);
}

Getopt::Long::Configure('no_ignore_case');

# The options values will be put in this hash
my %options;

# We define the command line options specifications by merging the
# common options and the the one specific to the command used
my %options_specs = %common_options_specs;
@options_specs{ keys( %{ $commands_options_specs{$command} } ) } = values( %{ $commands_options_specs{$command} } );

# We want to have only short options available for the user like the original
# command but we also want meaning full name in our options hash, to do
# that we dynamically create the GetOptions arguments based on the options
# specifications instead of using the native GetOptions way of storing options
# values in a hash
my %getoptions_args;
foreach my $option_name ( keys(%options_specs) ) {
    my $option_specs = $options_specs{$option_name};
    $options{$option_name} = exists( $option_specs->{default} ) ? $option_specs->{default} : undef;
    $getoptions_args{ $option_specs->{spec} } = \$options{$option_name};
}
GetOptions(%getoptions_args);

$package_manager_config{root_path} = $options{root_path};
my $pkgmgr = Package::Manager->new( \%package_manager_config );

#
my $command_sub = $available_commands{$command};
my $ret = &{$command_sub}( $pkgmgr, \%options, @ARGV );

exit( $ret ? 0 : 2 );

__END__
# POD start

=head1 NAME

svr4pkg - mimic the basic usage of Solaris native svr4 packages tools.

=head1 SYNOPSIS

svr4pkg [command] [option]... [package]...

=head1 DESCRIPTION

Svr4pkg is a tool to emulate the basic behaviour of the set of solaris tools used to manipulate
svr4 packages (pkgadd, pkgrm, pkginfo...).
It aimed at being used on illumos-based operating systems that do not provide the legacy
svr4 package tools, so that it's easy to install svr4 packages on these systems.

=head1 WARNING

Svr4pkg must not be used on a system where pkgadd, pkgrm are available. svr4pkg is not
guaranteed to be fully compatible with solaris native tools so you could mess badly
with the package database if you use both tools on the same system.

=head1 OPTIONS

The following options are implemented:

 - common options: -R
 - pkagadd:        -d, -v
 - pkgrm:          -d, -v
 - pkgchk:         -d
 - pkginfo:        -d, -l
 - installf:       -c
 - removef:

 Please refer to the man page of the original Solaris tools to know more about the
 various options.

=back

=head1 AUTHOR

Yann Rouillard <yann@pleiades.fr.eu.org>

=head1 COPYRIGHT AND DISCLAIMER

Copyright (C) 2013 Yann Rouillard. This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.

=cut

